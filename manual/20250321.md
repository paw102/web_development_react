# 금일 수업 계획
## useMemo 관련 실습
### useEffect 파트 복습
```jsx
import { useState, useEffect, useMemo } from "react";
import './app.css'

function App (){
  const [ number, setNumber ] = useState(0);
  const [ isTrue, setIsTrue ] = useState(true);

  const answer = isTrue ? "true" : "false";

  // answer 가 바뀔 때만 콘솔이 찍히도록 useEffect 적용
  useEffect(() => {
    console.log('answer 값이 변경되었습니다. 혹은 number 값이 변경되었습니다.');
  },[]);

  return(
    <div>
      <p>✨ Number</p>
      <input type="number" value={number} onChange={(e) => setNumber(e.target.value)} />
      <hr />
      <p>✨ Answer</p>
      <p> True or False? {answer}</p>
      <button onClick={(e) => setIsTrue(!isTrue)}>Reverse</button>
    </div>
  );
}

export default App;
```

```jsx
useEffect(() => {
  console.log('최초 렌더링 시에만 실행됩니다.(strictMode 시 두 번 실행됨)');
  },[]);
```
- 의존성 배열에 아무런 값이 없는 경우 : 최초 렌더링 시에 useEffect( ) 내의 콜백함수가 실행됨. (즉, 한 번만 실행됨(refresh)).

```jsx
useEffect(() => {
  console.log('answer 값이 변경되었습니다.');
  },[answer]);
```
- isTrue 의 값이 변경될 때마다 useEffect() 내의 콜백 함수가 실행됨 -> 버튼 누를 때마다 console.log 가 찍힘

```jsx
useEffect(() => {
  console.log('number 값이 변경되었습니다.');
  },[number]);
```
- input 창에 숫자를 입력할 때마다 (e.target.value 를 통해서 onChange 로 감지하기 때문) console.log 가 찍힘

```jsx
useEffect(() => {
  console.log('answer 값이 변경되었습니다. 혹은 number 값이 변경되었습니다.');
  },[answer, number]);
```
- input 에 값을 입력하거나 혹은 버튼을 누를 때 전부 console.log 가 찍히게 됨.

현재 기본 자료형인 answer(bool) 를 객체 타입으로 만들어줄거임.

```jsx
import { useState, useEffect, useMemo } from "react";
import './app.css'

function App (){
  const [ number, setNumber ] = useState(0);
  const [ isTrue, setIsTrue ] = useState(true);

  // const answer = isTrue ? "true" : "false 기초자료형 (primitive type)

  const answer = { bool : isTrue ? "true" : "false" };

  // answer 가 바뀔 때만 콘솔이 찍히도록 useEffect 적용
  useEffect(() => {
    console.log('answer 값이 변경되었습니다.');
  },[answer]);

  return(
    <div>
      <p>✨ Number</p>
      <input type="number" value={number} onChange={(e) => setNumber(e.target.value)} />
      <hr />
      <p>✨ Answer</p>
      {/* <p> True or False? {answer}</p> */}
      {/* <p> True or False? {answer.bool}</p> */}
      <p> True or False? {answer['bool']}</p>
      <button onClick={() => setIsTrue(!isTrue)}>Reverse</button>
    </div>
  );
}

export default App;
```

- 이상과 같이 수정했을 경우 number 만 변경했을 때에도 (즉 input 창에 숫자를 입력해도) 콘솔이 출력되고 있었음

-> 그러면 좀 이상한 게 의존성 배열이 [answer] 인데도 console.log 가 출력되고 있었으니까

-> isTrue 의 값이 숫자를 입력할 때마다 true <-> false 를 왔다갔다 하고 있다는 것을 의미함.

이상과 같은 동작이 발생하는 이유
- number 를 변경해서 컴포넌트가 리렌더링되면 함수형 컴포넌트인 App 안에 있는 변수들이 모두 초기화되어 다시 할당되기 때문에 객체 타입인 answer 가 다시 할당됨

그런데 객체 타입은 그 값이 변수에 직접 저장되는 것이 아니라, 메모리 주소값이 할당되어 그 값을 참조하게 됨

따라서 컴포넌트가 리렌더링되면 객체는 다른 메모리에 할당되고, 변수는 그에 맞는 주소값이 할당되게 됨. useEffect 는 렌더링 전과 후의 answer 주소값이 다르다고 판단하여 console.log 를 출력하게 됨.

- 즉, 사실 true <-> false 가 변하는 게 아니라, 메모리 주소값의 변경으로 인해서 발생한 것임.

```jsx
const answer = useMemo(() => {
  return { bool : isTrue ? "true" : "false" };
  }, [isTrue]);
```
- 이상과 같이 코드를 작성할 경우 (useMemo( ) 함수의 결과값을 answer 에 담았을 경우), 최초로 렌더링 될 때 객체의 주소값을 answer 상수가 메모이제이션함. 이후 리렌더링부터는 메모이제이션된 주소값을 재사용하게 됨.

- 따라서 반복적으로 리렌더링되더라도 useEffect 에 작성한 console.log 는 찍히지 않게 됨

### 정리 
- useMemo 는 메모이제이션으로 수행한 연산의 결과값을 기억함으로써 불필요한 계산을 최소화하고, 리렌더링을 막음.

## Js toDoList vs. React toDoList

npm create vite@4.3

reacttodoapp

react

js

폴더 들어가서 npm install

App.jsx 초기화.
assets 아이콘 파일도 삭제함.

커밋 푸시
## useEffect( ) 코인 현재 가격 추적기
